/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : JWT
 #	author : miyako
 #	2018/08/14
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

void OnStartup()
{
    //OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS, NULL);
}

long long int getlld(C_TEXT &Param)
{
    if(Param.getUTF16Length())
    {
        CUTF8String num;
        Param.copyUTF8String(&num);
        char *end;
        return strtoll((const char *)num.c_str(), &end, 10);
    }
    
    return 0;
}

long long int getlld(std::string &num)
{
    if(num.length())
    {
        char *end;
        return strtoll(num.c_str(), &end, 10);
    }
    
    return 0;
}

void convertFromString(std::string &fromString, C_TEXT &toString)
{
#ifdef _WIN32
    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)fromString.c_str(), fromString.length(), NULL, 0);
    
    if(len){
        std::vector<uint8_t> buf((len + 1) * sizeof(PA_Unichar));
        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)fromString.c_str(), fromString.length(), (LPWSTR)&buf[0], len)){
            CUTF16String u16 = CUTF16String((const PA_Unichar *)&buf[0]);
            toString.setUTF16String(&u16);
        }
    }else{
        CUTF16String u16 = CUTF16String((const PA_Unichar *)L"\0\0");
        toString.setUTF16String(&u16);
    }
#else
    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)fromString.c_str(), fromString.length(), kCFStringEncodingUTF8, true);
    if(str){
        int len = CFStringGetLength(str);
        std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
        CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
        CUTF16String u16 = CUTF16String((const PA_Unichar *)&buf[0]);
        toString.setUTF16String(&u16);
        CFRelease(str);
    }
#endif
}

void convertToString(C_TEXT &fromString, std::string &toString)
{
#ifdef _WIN32
    int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)fromString.getUTF16StringPtr(), fromString.getUTF16Length(), NULL, 0, NULL, NULL);
    
    if(len){
        std::vector<uint8_t> buf(len + 1);
        if(WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)fromString.getUTF16StringPtr(), fromString.getUTF16Length(), (LPSTR)&buf[0], len, NULL, NULL)){
            toString = std::string((const char *)&buf[0]);
        }
    }else{
        toString = std::string((const char *)"\0");
    }
#else
    CFStringRef str = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar *)fromString.getUTF16StringPtr(), fromString.getUTF16Length());
    if(str){
        
        size_t size = CFStringGetMaximumSizeForEncoding(CFStringGetLength(str), kCFStringEncodingUTF8) + sizeof(uint8_t);
        std::vector<uint8_t> buf(size);
        CFIndex len = 0;
        CFStringGetBytes(str, CFRangeMake(0, CFStringGetLength(str)), kCFStringEncodingUTF8, 0, true, (UInt8 *)&buf[0], size, &len);
        
        toString = std::string((const char *)&buf[0], len);
        CFRelease(str);
    }
#endif
}

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- JWT

		case 1 :
			JWT_Timestamp(pResult, pParams);
			break;

		case 2 :
			JWT_Sign(pResult, pParams);
			break;

		case 3 :
			JWT_Verify(pResult, pParams);
			break;

	}
}

// -------------------------------------- JWT -------------------------------------


void JWT_Timestamp(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    long long int time_1 = getlld(Param1);
    long long int time_2 = getlld(Param2);
    
    if(time_1 == 0)
    {
#if VERSIONWIN
        static const __int64 SECS_BETWEEN_1601_AND_1970_EPOCHS = 116444736000000000LL;
        FILETIME ft;
        GetSystemTimeAsFileTime(&ft);
        ULARGE_INTEGER ul;
        ul.LowPart = ft.dwLowDateTime;
        ul.HighPart = ft.dwHighDateTime;
        time_1 = (long long int)((ul.QuadPart - SECS_BETWEEN_1601_AND_1970_EPOCHS) / 10000);
#else
        struct timeb timer_msec;
        long long int timestamp_msec;
        if (!ftime(&timer_msec))
        {
            time_1 = ((long long int) timer_msec.time) * 1000ll + (long long int) timer_msec.millitm;
        }
#endif
    }
    
    time_1 += time_2;
    
    std::vector<uint8_t>buf(100);
    int len = snprintf ( (char *)&buf[0], 100, "%lld", time_1);
    
    if(0 < len)
    {
        returnValue.setUTF8String((const uint8_t *)&buf[0], len);
    }
    
    returnValue.setReturn(pResult);
}

void JWT_Sign(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);

    using namespace Json;
    using namespace std;
    using namespace jose;
    
    string header_json;
    convertToString(Param1, header_json);
    
    string payload_json ;
    convertToString(Param2, payload_json);
    
    string private_key;
    convertToString(Param3, private_key);
    
    Value root;
    CharReaderBuilder builder;
    string errors;
    
    CharReader *reader = builder.newCharReader();
    bool parse = reader->parse(payload_json.c_str(),
                               payload_json.c_str() + payload_json.size(),
                               &root,
                               &errors);
    delete reader;
    
    if(parse)
    {
        for(Value::const_iterator it = root.begin() ; it != root.end() ; it++)
        {
            Value key = it.key();
            JSONCPP_STRING name = it.name();
            /* cast IntDate from string to int [exp,iat,nbf] */
            if((name == "exp") || (name == "iat") || (name == "nbf"))
            {
                if(it->isString())
                {
                    string value = it->asString();
                    root[name] = getlld(value);
                }
            }
        }
        payload_json = root.toStyledString();
    }
    
    reader = builder.newCharReader();
    parse = reader->parse(header_json.c_str(),
                          header_json.c_str() + header_json.size(),
                          &root,
                          &errors);
    delete reader;
    
    alg alg = alg::NONE;
    
    if(parse)
    {
        for(Value::const_iterator it = root.begin() ; it != root.end() ; it++)
        {
            Value key = it.key();
            JSONCPP_STRING name = it.name();

            if(name == "alg")
            {
                if(it->isString())
                {
                    string value = it->asString();
                    if(value == "HS256")
                    {
                        alg = alg::HS256;
                        break;
                    }
                    if(value == "HS384")
                    {
                        alg = alg::HS384;
                        break;
                    }
                    if(value == "HS512")
                    {
                        alg = alg::HS512;
                        break;
                    }
                    if(value == "RS256")
                    {
                        alg = alg::RS256;
                        break;
                    }
                    if(value == "RS384")
                    {
                        alg = alg::RS384;
                        break;
                    }
                    if(value == "RS512")
                    {
                        alg = alg::RS512;
                        break;
                    }
                    if(value == "ES256")
                    {
                        alg = alg::ES256;
                        break;
                    }
                    if(value == "ES384")
                    {
                        alg = alg::ES384;
                        break;
                    }
                    if(value == "ES512")
                    {
                        alg = alg::ES512;
                        break;
                    }
                    if(value == "UNKNOWN")
                    {
                        alg = alg::UNKNOWN;
                        break;
                    }
                }
            }
        }
    }

    string header_b64, payload_b64;
    string token;
    string bearer;
    string sign;
    
    try
    {
        hdr hdr(header_json);
        header_b64 = hdr.b64();
        
        claims claims(payload_json);
        payload_b64 = claims.b64();
        
        token = header_b64 + "." + payload_b64;
        
        BIO *bio = BIO_new_mem_buf((const void *)private_key.c_str(), private_key.length());
        
        if(bio)
        {
            RSA *key = NULL;
            key = PEM_read_bio_RSAPrivateKey(bio, NULL, NULL, NULL);
            if(key)
            {
                sp_rsa_key sp_key = sp_rsa_key(RSAPrivateKey_dup(key), ::RSA_free);
                sp_rsa_key pubkey = sp_rsa_key(RSAPublicKey_dup(sp_key.get()), ::RSA_free);
                
                sp_crypto sp_crp = make_shared<rsa>(alg, sp_key);
                sp_crypto sp_crp_pub = make_shared<rsa>(alg, pubkey);
                
                /* sign_claims removes all properties except alg and typ */
                string sign = jws::sign(token, sp_crp);
                bearer = token + "." + sign;
            }
            BIO_free(bio);
        }
        
    }catch(...)
    {
        
    }
    
    convertFromString(bearer, returnValue);
	returnValue.setReturn(pResult);
}

void JWT_Verify(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);

    using namespace Json;
    using namespace std;
    using namespace jose;
    
    alg alg = alg::NONE;
    
    string bearer;
    convertToString(Param1, bearer);
    
    size_t pos = bearer.find(".");
    if(pos != string::npos)
    {
        string header = bearer.substr(0, pos);
        pos = header.find("Bearer ");
        
        if(pos != string::npos)
        {
            header = header.substr(pos + 7);
        }
        std::string header_json = b64::decode(header);
        
        Value root;
        CharReaderBuilder builder;
        string errors;
        
        CharReader *reader = builder.newCharReader();
        bool parse = reader->parse(header_json.c_str(),
                                   header_json.c_str() + header_json.size(),
                                   &root,
                                   &errors);
        delete reader;
        
        pos = bearer.find("Bearer ");
        
        if(pos == string::npos)
        {
            bearer = "Bearer " + bearer;
        }
        
        if(parse)
        {
            for(Value::const_iterator it = root.begin() ; it != root.end() ; it++)
            {
                Value key = it.key();
                JSONCPP_STRING name = it.name();
                
                if(name == "alg")
                {
                    if(it->isString())
                    {
                        string value = it->asString();
                        if(value == "HS256")
                        {
                            alg = alg::HS256;
                            break;
                        }
                        if(value == "HS384")
                        {
                            alg = alg::HS384;
                            break;
                        }
                        if(value == "HS512")
                        {
                            alg = alg::HS512;
                            break;
                        }
                        if(value == "RS256")
                        {
                            alg = alg::RS256;
                            break;
                        }
                        if(value == "RS384")
                        {
                            alg = alg::RS384;
                            break;
                        }
                        if(value == "RS512")
                        {
                            alg = alg::RS512;
                            break;
                        }
                        if(value == "ES256")
                        {
                            alg = alg::ES256;
                            break;
                        }
                        if(value == "ES384")
                        {
                            alg = alg::ES384;
                            break;
                        }
                        if(value == "ES512")
                        {
                            alg = alg::ES512;
                            break;
                        }
                        if(value == "UNKNOWN")
                        {
                            alg = alg::UNKNOWN;
                            break;
                        }
                    }
                }
            }
        }
    }
    
    string private_key;
    convertToString(Param2, private_key);
    
    try
    {
        BIO *bio = BIO_new_mem_buf((const void *)private_key.c_str(), private_key.length());
        
        if(bio)
        {
            RSA *key = NULL;
            key = PEM_read_bio_RSAPrivateKey(bio, NULL, NULL, NULL);
            if(key)
            {
                sp_rsa_key sp_key = sp_rsa_key(RSAPrivateKey_dup(key), ::RSA_free);
                sp_rsa_key pubkey = sp_rsa_key(RSAPublicKey_dup(sp_key.get()), ::RSA_free);
                
                sp_crypto sp_crp = make_shared<rsa>(alg, sp_key);
                sp_crypto sp_crp_pub = make_shared<rsa>(alg, pubkey);
                
                sp_jws jws = jws::parse(bearer);
                returnValue.setIntValue(jws->verify(sp_crp_pub));
            }
            BIO_free(bio);
        }
    }catch(...)
    {
        
    }
    
	returnValue.setReturn(pResult);
}

